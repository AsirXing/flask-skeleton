0) Clone a copy of the skeleton:

   git clone git@github.com:sean-/flask-skeleton.git


0a) I use tcsh(1) for day-to-day use and then sh(1) for scripting. Most
    bash(1) enthusiasts don't have enough perspective to have an opinion
    worth listening to. New tcsh users, enjoy the up-arrow history,
    tab-completion for ssh hosts, `time long_command`, etc., ...

    See https://github.com/sean-/cshrc for details, or just:

    $ curl -o ~/.cshrc https://github.com/sean-/cshrc/raw/master/.cshrc
    $ less ~/.cshrc     # _Always_ review changes to your shell config
    $ exec /bin/tcsh    # Start using tcsh(1)
    % chsh /bin/tcsh    # Change your default shell once you feel comfortable


1) Rename from 'skeleton' to 'myapp':

   # At some point I'll change this step to be scripted
   find . -type f -print0 | xargs -0 -n 1 perl -p -i -e '#skeleton#myapp#go'
   mv skeleton myapp
   # Search for and replace the remaining references to 'skeleton'
   egrep -ri skeleton *
   find . | grep -i skeleton


2) Start the database:

   # MacPorts installed version of PostgreSQL 9.1
   sudo su - pgsql -c '/opt/local/lib/postgresql91/bin/postgres -D /opt/local/var/db/postgresql91/defaultdb'


3) Create a virualenv for the skeleton:

   # MacPorts installed version of Python 2.7
   /opt/local/Library/Frameworks/Python.framework/Versions/2.7/bin/virtualenv --no-site-packages .


4) Activate the virtualenv:

   # If you installed the .cshrc file listed above and use tcsh(1), just do this:
   chmod 0600 .enter.tcsh
   cd $PWD

   # To manually activate the virtualenv, run the following:
   source bin/activate.csh


5) Pull in the required packages. This step is a bit goofy due to PostgreSQL's
   pg_config being hidden away out of the normal path.

   # Tweak your path to where pg_config(1) is hidden
   setenv PATH /opt/local/lib/postgresql91/bin/:${PATH}

   # Break the installation down in to two steps: download and install (if
   # something fails, you don't want to start over again from scratch). ~/tmp
   # is created by .cshrc.

   pip install -U --download-cache=~/tmp -I -r requirements.txt --no-install
   pip install -U --download-cache=~/tmp -I -r requirements.txt --no-download

   # Make sure everything is there (or newer):
   pip freeze | sort > requirements.txt
   git diff requirements.txt


6) Setup debugging:

   echo 'DEBUG = True' >> local_settings.py
   echo 'TESTING = True' >> local_settings.py

   When you go in to production, be sure to remove these two lines!!!


7) Initialize the database (these steps should be moved in to a script for
   easy unit testing):

   # l2dba 101

   # Create the admin ROLE and web user
   psql template1 pgsql -1f sql/create_roles.sql

   # Create the database. Don't pull a MySQL and use ISO-8895-1
   psql template1 pgsql -c "CREATE DATABASE skeleton OWNER skeleton_admin ENCODING='UTF8' LC_COLLATE='en_US.UTF-8' LC_CTYPE='en_US.UTF-8'"

   # Load the pgcrypto and uuid functions in to skeleton
   cat /opt/local/share/postgresql91/extension/pgcrypto--1.0.sql | sed -e 's#MODULE_PATHNAME#pgcrypto#' > ~/tmp/pgcrypto.sql
   cat /opt/local/share/postgresql91/extension/uuid-ossp--1.0.sql | sed -e 's#MODULE_PATHNAME#uuid-ossp#' > ~/tmp/uuid-ossp.sql
   psql skeleton pgsql -1f ~/tmp/pgcrypto.sql
   psql skeleton pgsql -1f ~/tmp/uuid-ossp.sql

   # Load the schema
   psql skeleton skeleton_admin -1 -f sql/schema.sql

   # Load the functions. This loads the functions and changes their
   # permissions. Change DATABASE_PASSWORD_HASH to a random string of bytes
   # that's at least 32 bytes in length. Please use secure key handling
   # techniques and make sure that the DATABASE_PASSWORD_HASH key only exists
   # on your database servers and is not present (in any capacity) along side
   # with your webserver password keys.
   pwgen -acn 32 1 > sql/db_password.hash
   psql -At skeleton skeleton -c 'SELECT uuid_generate_v4();' > sql/database_email.uuid
   sed -e "s#DATABASE_PASSWORD_HASH#`cat sql/db_password.hash`#" \
       -e "s#DATABASE_EMAIL_UUID#`cat sql/database_email.uuid`#" sql/funcs.sql.in > sql/funcs.sql
   psql skeleton skeleton_admin -1f sql/funcs.sql

   # CREATE TRIGGER commands are run outside of funcs.sql because there is no
   # "CREATE OR REPLACE TRIGGER" syntax.
   psql skeleton skeleton_admin -1f sql/triggers.sql

   # ALTER FUNCTION ... OWNER TO ... commands must be run by the pgsql user.
   psql skeleton pgsql -1f sql/fixup_func_owner.sql

   # Add aaa and mod1 to the skeleton_www user's default search_path. This
   # only needs to be done when you create a new user.
   psql skeleton pgsql -c 'ALTER ROLE skeleton_www SET search_path = aaa, mod1, public'

   # Populate some initial data
   psql skeleton skeleton_admin -1f sql/initial_data.sql

   # Setup the GRANTS. Be sure to audit the database permissions after the
   # fact via the psql(1) commands: \dp, \ddp and \dn+
   psql skeleton skeleton_admin -1 -f sql/perms.sql

   # Other misc PostgreSQL tips:
   #
   # 1) Look in to using the contrib'ed auto-explain module:
   #    http://www.postgresql.org/docs/current/static/auto-explain.html
   #
   # 2) A few suggested development tunables for postgresql.conf:
	# shared_preload_libraries = 'pgcrypto,uuid-ossp'
	# synchronous_commit = off
	# log_connections = on
	# log_disconnections = on
	# log_duration = on
	# log_statement = 'all'
	# timezone = 'UTC'
   #
   # 3) Learn how to use dblink (and get creative with its use in functions
   #    and views):
   #    http://www.postgresql.org/docs/current/static/dblink.html
   #
   # 4) Always use pgbouncer (http://wiki.postgresql.org/wiki/PgBouncer). I
   #    recommend using PostgreSQL on 127.0.0.1:6432 and then pgbouncer on
   #    *:5432. Be sure to check out the 'pgbouncer' database and run the
   #    'SHOW STATS' commands.
   #
   # 5) Small reading comprehension test: until you set the database or the
   #    connection's timezone to UTC, timezone to UTC, you will get
   #    '*check1'-like errors.


8) Run the app:

    python runserver.py

    # The first few times you run runserver.py, it will puke up errors and
    # have you add various bits to local_settings.py. It is critically
    # important that:
    #
    # a) PASSWORD_HASH: All webservers have the same PASSWORD_HASH. If you
    #    loose PASSWORD_HASH, users will not be able to log in. The contents
    #    of PASSWORD_HASH should never exist on your database servers.
    #
    # b) sql/db_password.hash: The contents of sql/db_password.hash should
    #    never be present on your webservers. Like PASSWORD_HASH, if you
    #    loose the contents of db_password.hash, users will not be able to
    #    log in without resetting their password (on the plus side, at least
    #    db_password.hash is stored in the contents of the pl functions -
    #    which are visible to any logged in user, regardless of the
    #    permissions set on the function's enclosing schema and the function
    #    itself).
    #
    # c) SECRET_KEY: SECRET_KEY must be syncronized across all webservers,
    #    too, but unlike PASSWORD_HASH, you can regenerate it at any time and
    #    there's no real loss (users will have to re-login).
    #
    # d) BROWSER_SECRET_KEY: Similar story to SECRET_KEY. All web servers
    #    must have the same BROWSER_SECRET_KEY. If you loose this key, every
    #    BrowserID cookie will be reset. Not the end of the world, but
    #    tedious as hell to recover from.
    #
    # e) SSL_CERT_FILENAME and SSL_PRIVATE_KEY_FILENAME: These are your SSL
    #    certs. Don't loose them. Don't use Werkzeug for handling SSL in
    #    production, but it's really convenient to test in an SSL environment
    #    from the beginning.



9) Remove the remnants of git:

   rm -rf .git .gitignore


10) Setup fossil (my preferred SCM of choice atm: http://www.fossil-scm.org/):

   alias fs fossil
   mkdir -p ~/src/.fossils
   fs new ~/src/.fossils/skeleton.fossil
   fs open ~/src/.fossils/skeleton.fossil

   # Settings generated via:
   # fs set | grep local | awk '{print "fs set " $1 " " $3}'
   fs set autosync 1
   fs set clearsign 1
   fs set editor vi
   fs set ignore-glob bin/*,include/*,lib/*,local_settings.py,*.pyc
   fs set localauth 0
   fs set pgp-command gpg2
   fs addremove
   fs ci -m "Initial checkin of skeleton app"


11) In production, you will need to combine all of your static assets
    together and probably have them served by nginx. Something like:

    mkdir static
    cd static
    find ../skeleton -name static
    # Make a symlink for everything in to the static dir. e.g.:
    # ln -s ../skeleton/modules/mod1/static mod1


12) Feel free to re-run the sql/perms.sql script as many times as you'd
    like. \dp, \ddp and \dn+ are your friends.
