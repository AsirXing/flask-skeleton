See below for a list of completed items. Things still in progress (roughly in
order of priority):

*) Logout = kill session in memcache
   *) Loop detection for clients that have cookies disabled
   *) Add no cookie page
   *) Reissue cookie id's older than 24hrs
   *) Cookies can have their freshness reset after 10min of life. A cookie
      looses its fresh status after 20min of total life if not
      refreshed. Each cookie has a timestamp that it was issued, a min
      renewal time and a max freshness life.
   *) Include the level of strength of the authenticated session (password,
      old/renewed token, or 2FA auth'ed token)
   *) Integrate/use Flask-Login where possible?
*) Add per-user timezone support
*) Localization (Flask-Babel)
*) Cache a user-object upon login in memcache
*) Beef up the @logged_in decorator so that it:
    a) checks memcache for a matching session
    b) Logs a user out if their session has expired (or updates it accordingly)
    c) Populates memcache with a user object upon cache miss
*) Add authorization decorators. Each session id needs to be given an
   authorization token that gets refreshed every 300sec. User automatically
   gets redirected from the decorator with the missing or expired token and
   requests an authorization token that lasts for a given app for 300sec.
*) Unit testing framework
*) Migrate to using setup.py instead of providing a fixed requirements.txt
*) Scripting via Flask-Script (both shell setup and cron-like jobs)
*) Services API example (XML, maybe protobuf)
*) Add support for insecure and secure cookies
*) pgmemcache
*) Create readonly and readwrite roles for DBAs


Alpha sorted list of demonstrated components (some better than others):

AAA (Access, Authentication, Authorization):
  *) Login (via pl functions)
  *) Logout
  *) Registration

Application:
  *) Integration with other WSGI Middleware's
  *) Modularized development (filesystem layout)
  *) Session management (secure cookie handling)
  *) Static assets management

Database (PostgreSQL):
  *) Give each "application class" different database users to connect as
  *) Ordered list of .sql files to execute in order to recreate (and
     maintain) the database.
  *) ORM Layer and examples
  *) PostgreSQL pl functions
  *) Use schemas as a management tool for setting correct permissions
  *) Use a "DBA" role for owning objects and a DBA user for per-user
     connections

Caching (memcached):
  *) memoized functions
  *) Objects
  *) Views

Development:
  *) Application profiling
  *) Debugging toolbar

ORM (SQLAlchemy):
  *) Declarative table use
  *) Use of PostgreSQL functions with SQLAlchemy

Templating (Jinja2):
  *) Template filters
  *) Template layout
